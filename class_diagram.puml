/'
This is our model for the class diagram. Whenever you have any remarks
to make regarding one part of the program or another, just make a
comment windows in here like this.
Sign it with your initials as well. -MI
'/

/'
We can have a nice separation of labor: each one of us gets to implement
a max biclique algorithm and one of the following parts:
- Tests
- UI and input
- Graphs and graph parsing.
-MI
I agree with this partitioning.
I would like to work on the UI (since I have already done some work for that). -RK
'/

@startuml

package bicliques {

' The graph section
package bicliques.graphs {

  interface Graph {
    {method}{abstract} + getVertices() : Vertex[]
    {method}{abstract} + getVertexCount() : int
    {method}{abstract} + getEdges() : Edge[]
    {method}{abstract} + getEdgeCount() : int

/'
I don't think these two methods should be in the general graph interface.
The maximum biclique algorithm class should be the one owning the graph
class and not the other way around. - MI
'/
    {method}{abstract} + setMBA(MaximalBicliqueAlgorithm)
    {method}{abstract} + maxBicliques() : Bicliques[]
  }

  interface Vertex {
    {method}{abstract} + getNeighbours() : Vertex[]
    {method}{abstract} + getEdges() : Edge[]
    {method}{abstract} + getStar() : Biclique
  }
  
  interface Edge {
    {method}{abstract} + getStart() : Vertex
    {method}{abstract} + getEnd() : Vertex
  }

  Vertex -* Graph
  Edge -* Graph
  
  class BipartiteGraph {
    {field} - left : Vertex[]
    {field} - right : Vertex[]
    {field} - edges : Edge[]
    {field} - mba : MaximalBicliquesAlgorithm
    {method} + BipartiteGraph(Vertex[], Vertex[], Edge[])
    {method} + getLeft() : Vertex[]
    {method} + getRight() : Vertex[]
  }
  
  Graph <|.. BipartiteGraph
  
}


' The UI section
package bicliques.ui {

/'
For the UI part I say we need to come up with something, that can read in
the text files (I don't want to be copying and pasting stuff in the windows
every time I use it). - MI.

So do I. In my suggested screenshot of a possible UI the menu would provide
- Input: load (from file) or from input in window
- Output: save (to file)
- Algorithm: choose between several implemented ones
- Help: Description of algorithms and the common "About".
-RK
'/

  class MaxBicliqueGUI {
    {method}{static} + main(String[]): void
  }
}

' The algorithms section
package bicliques.algorithms {

  class Biclique {
    {field} - left : Vertex[]
    {field} - right : Vertex[]
/'
Why should we need access to a graph from a biclique? -RK

Because the bicliques are defined by the graph, more or less.
To me it makes sense in term of program logic.
Put it back in if you agree. - MI

'    {field} - graph : Graph
'/
	{method} + Biclique(Vertex[], Vertex[])
    {method} + getLeft() : Vertex[]
    {method} + getRight() : Vertex[]
/'
Why should we need access to a graph from a biclique? -RK
'    {method} + getGraph() : Graph[] --o Graph
'/
    {method} + absorbs(Biclique) : boolean
    {method} + consensus(Biclique) : Biclique[]
    {method} + bipartiteConsensus(Biclique) : Biclique[]
  }

  Biclique --* Graph

  interface MaximalBicliquesAlgorithm {
    {method}{abstract} + findMaxBicliques(Graph) : Biclique[]
  }

  /'
  MICA algorithm improved for bipartite graphs. -RK
  '/
  class MICAB {
  }
  
  MaximalBicliquesAlgorithm <|.. MICAB
  
}

package bicliques.test {

/'
The testing that we will need. I say we use junit 4 or 5
to make it more streamlined. -MI
I agree. -RK
'/

}

}

@enduml
